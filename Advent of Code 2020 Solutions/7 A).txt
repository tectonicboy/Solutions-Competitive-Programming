#include <string>
#include <algorithm>
#include <vector>
#include <cmath>
#include <iostream>
#include <iterator>
#include <tuple>

using namespace std;

class BagColor {
public:
	string m_name = "";
	vector<string> m_valid_colors;
	bool Y = false;
	BagColor(string& col, vector<string> &vector) : m_name(col), m_valid_colors(vector){}
};

vector<BagColor> vec = {};
string required = "shinygold";
void CheckColor(BagColor& C) {
	BagColor* ptr = &C;
	for (size_t i = 0; i < C.m_valid_colors.size(); ++i) {
		for (size_t j = 0; j < vec.size(); ++j) {
			if (C.m_valid_colors[i] == vec[j].m_name) {
				ptr = &vec[j];
				break;
			}
		}
		if (C.m_valid_colors[i] == required || ptr->Y) {
			C.Y = true;
			break;
		}
		CheckColor(*ptr);

	}
}

int main() {
	vector<string> valid_colors = {};
	string line = "", name = "", color = "";
	size_t FOUND;
	int x = 0, counter = 0;
	bool space_found = false;
	while (getline(cin, line)) {
		if (line == "END") { break; }
		for (size_t i = 0; i < line.size(); ++i) {
			if (line[i] == ' ') { 
				if (!space_found) { 
					space_found = true; 
					name.push_back(line[i]);
					continue;
				}
				else {
					space_found = false;
					FOUND = line.find("no other");
					if (FOUND != std::string::npos) {
						break;
					}
					i += 15;
					for (size_t j = i + 1; j < line.size(); ++j) {
						if ((j+(x-3)) == line.size() - 1) {
							color.push_back(line[j]);
							valid_colors.push_back(color);
							break;
						}
						if (line[j] == ' ') {
							if (!space_found) {
								space_found = true;
								color.push_back(line[j]);
								continue;
							}
							else {
								space_found = false;
								valid_colors.push_back(color);
								if (line[j + 4] == 's') {x = 8;}
								else { x = 7; }
								j += x;
								color = "";
							}
						}
						else { color.push_back(line[j]); }
					}
					break;
				}
			}
			else { name.push_back(line[i]); }
		}
		vec.push_back(BagColor(name, valid_colors));
		name = "";
		color = "";
		valid_colors = {};
		space_found = false;
	}
	for (size_t i = 0; i < vec.size(); ++i) {
		for (size_t j = 0; j < vec[i].m_name.size(); ++j) {
			if (vec[i].m_name[j] == ' ') { vec[i].m_name.erase(vec[i].m_name.begin() + j); }
		}
		cout << vec[i].m_name << " : ";
		for (size_t j = 0; j < vec[i].m_valid_colors.size(); ++j) {
			for (size_t k = 0; k < vec[i].m_valid_colors[j].size(); ++k) {
				if (vec[i].m_valid_colors[j][k] == ' ') {
					vec[i].m_valid_colors[j].erase(vec[i].m_valid_colors[j].begin() + k);
				}
			}
			cout << vec[i].m_valid_colors[j] << ", ";
		}
		cout << "\n";
	}

	for (int M = 0; M < 20; ++M) {
		for (size_t i = 0; i < vec.size(); ++i) {
			cout << "Analyzing: " << vec[i].m_name << "\t\t at i = " << i << "\t AT CHECK: " << M << "\n";
			CheckColor(vec[i]);
		}
	}
	counter = 0;
	for (size_t i = 0; i < vec.size(); ++i) {
		if (vec[i].Y) { ++counter; }
	}


	cout << "After 20 checks, " << counter << " are found.\n";

	return 0;
}